// paramètres du tube

real diametreTube = 1e-1;
real rayonTube = diametreTube / 2;

real alpha = pi / 4;     // angle incidence
real longueurTubeY = 1;  // longueur sur l'axe des abscisses de la partie en Y
real longueurTube1 = 1;  // longueur sur l'axe des abcisses de la suite du Y
real d0 = diametreTube / sin(alpha) - rayonTube / tan(alpha);

// paramètres de la section de chauffe

real[int] translationChauffe =
    [ rayonTube, rayonTube ];  // vecteur de translation de la partie de chauffe
real nbOscillations = 4 + 0.5;
real longueurOscillations = 1;
real hauteurOscillations = 2 * rayonTube;
real k = 2 * pi * nbOscillations / longueurOscillations;  // pulsation

// liste des points de la partie en Y du tube

real[int] p1 = [ longueurTubeY + d0 + longueurTube1, -rayonTube ];
real[int] p2 = [ longueurTubeY + d0, -rayonTube ];
real[int] p3 = [ 0, -longueurTubeY *tan(alpha) - diametreTube / cos(alpha) ];
real[int] p4 = [ 0, -longueurTubeY *tan(alpha) ];
real[int] p5 = [ longueurTubeY, 0 ];
real[int] p6 = [ 0, longueurTubeY *tan(alpha) ];
real[int] p7 = [ 0, longueurTubeY *tan(alpha) + diametreTube / cos(alpha) ];
real[int] p8 = [ longueurTubeY + d0, rayonTube ];
real[int] p9 = [ longueurTubeY + d0 + longueurTube1, rayonTube ];

// construction des bords de la partie en Y du tube

border bord1(t = 0, 1) {
  x = p1[0] + t * (p2[0] - p1[0]);
  y = p1[1] + t * (p2[1] - p1[1]);
}

border bord2(t = 0, 1) {
  x = p2[0] + t * (p3[0] - p2[0]);
  y = p2[1] + t * (p3[1] - p2[1]);
}

border bord3(t = 0, 1) {
  x = p3[0] + t * (p4[0] - p3[0]);
  y = p3[1] + t * (p4[1] - p3[1]);
}

border bord4(t = 0, 1) {
  x = p4[0] + t * (p5[0] - p4[0]);
  y = p4[1] + t * (p5[1] - p4[1]);
}

border bord5(t = 0, 1) {
  x = p5[0] + t * (p6[0] - p5[0]);
  y = p5[1] + t * (p6[1] - p5[1]);
}
border bord6(t = 0, 1) {
  x = p6[0] + t * (p7[0] - p6[0]);
  y = p6[1] + t * (p7[1] - p6[1]);
}

border bord7(t = 0, 1) {
  x = p7[0] + t * (p8[0] - p7[0]);
  y = p7[1] + t * (p8[1] - p7[1]);
}

border bord8(t = p8[0], p9[0]) {
  x = t;
  y = p8[1] + t * (p9[1] - p8[1]);
}

// construction de la partie de chauffe

border hautChauffe(t = 0, longueurOscillations) {
  x = p9[0] + translationChauffe[0] + t;
  y = p9[1] + translationChauffe[1] + hauteurOscillations * sin(k * t);
}

border basChauffe(t = longueurOscillations, 0) {
  x = p1[0] + translationChauffe[0] + t;
  y = p1[1] + translationChauffe[1] + hauteurOscillations * sin(k * t);
}

// fonction qui renvoie les coefficients du polynome pour l'interpolation de
// degré 3 entre A(xa, ya) et B(xb, yb) avec une penteA en A et penteB en B
// le proof of concept est donné dans le fichier python, mais l'inversion de
// matrice ne fonctionne pas ici encore ..
// ça marche maintenant, mais j'ai trouvé une ruse on en a plus besoin xd
// peut être quand même l'utiliser ?

/*
func real[int] interpolation(real[int] A, real[int] B, real penteA,
                             real penteB) {
  matrix vandermonde =
      [[A [0] ^ 3, A [0] ^ 2, A [0], 1], [B [0] ^ 3, B [0] ^ 2, B [0], 1],
       [3 * A [0] ^ 2, 2 * A [0], 1, 0], [3 * B [0] ^ 2, 2 * B [0], 1, 0]];
  real[int] sndmembre = [ A[1], B[1], penteA, penteB ];
  set(vandermonde, solver = sparsesolver);
  real[int] sol = vandermonde ^ -1 * sndmembre;
  return sol;
}

real[int] A = [0, 0];
real[int] B = [1, 1];

real[int] coeffs2 = interpolation(A, B, 0, 9);
cout << coeffs2;
// ne fonctionait pas, en attendant, on interpole sur [0, 1] et on translate :

*/

// construction de la jonction entre le Y et la section de chauffe

real[int] p10 = p9 + translationChauffe;
real pente = hauteurOscillations * k;
real penteB =
    pente * (p10[0] - p9[0]) / (p10[1] - p9[1]);  // pente équivalente en x = 1

// regression polynomiale
matrix invvandermonde =
    [ [ 2, -2, 1, 1 ], [ -3, 3, -2, -1 ], [ 0, 0, 1, 0 ], [ 1, 0, 0, 0 ] ];
real[int] sndmembre = [ 0, 1, 0, penteB ];
real[int] coeffs = invvandermonde * sndmembre;

border jonctionHaut(t = 0, 1) {
  x = p9[0] + t * (p10[0] - p9[0]);
  y = p9[1] +
      (coeffs[0] * t ^ 3 + coeffs[1] * t ^ 2 + coeffs[2] * t + coeffs[3]) *
          (p10[1] - p9[1]);
}

border jonctionBas(t = 1, 0) {
  x = p1[0] + t * (p10[0] - p9[0]);
  y = p1[1] +
      (coeffs[0] * t ^ 3 + coeffs[1] * t ^ 2 + coeffs[2] * t + coeffs[3]) *
          (p10[1] - p9[1]);
}

border jonctionHaut2(t = 1, 0) {
  x = p9[0] + p10[0] - p9[0] + longueurOscillations +
      (1 - t) * (p10[0] - p9[0]);  // symétrie axe x = 1/2
  y = p9[1] +
      (coeffs[0] * t ^ 3 + coeffs[1] * t ^ 2 + coeffs[2] * t + coeffs[3]) *
          (p10[1] - p9[1]);
}

border jonctionBas2(t = 0, 1) {
  x = p1[0] + p10[0] - p9[0] + longueurOscillations +
      (1 - t) * (p10[0] - p9[0]);  // symétrie axe x = 1/2
  y = p1[1] +
      (coeffs[0] * t ^ 3 + coeffs[1] * t ^ 2 + coeffs[2] * t + coeffs[3]) *
          (p10[1] - p9[1]);
}

int nbArretes = 10;

// affichage du domaine

plot(bord1(nbArretes) + bord2(nbArretes) + bord3(nbArretes) + bord4(nbArretes) +
     bord5(nbArretes) + bord6(nbArretes) + bord7(nbArretes) + bord8(nbArretes) +
     hautChauffe(10 * nbArretes) + basChauffe(10 * nbArretes) +
     jonctionHaut(nbArretes) + jonctionBas(nbArretes) +
     jonctionHaut2(nbArretes) + jonctionBas2(nbArretes));
