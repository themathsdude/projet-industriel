// param√®tres de l'EDP

real dt = 0.1;
real mu = 1;
real dP = 10;
real eta = 1;  // 1e-6;
real theta = 1;

// Params 
real vbar, xbar, ubar, pbar, rho, tbar;
real Re;
real A;

vbar = 1e-12;
xbar = 1e-6;
ubar = 1e-3;
pbar = 1e4;
rho = 1e3;
tbar = 1;


func real visc(real theta){
    real a, b, c, d, e, f;
    a = 2.29420356e-18;
    b = -8.23607663e-16;
    c = -2.71489819e-12;
    d = 5.93544667e-10;
    e = -4.52040818e-08;
    f = 1.72321673e-06;

    return a * theta^5 + b * theta^4 + c * theta^3 + d * theta^2 + e * theta + f;
}

Re = ((xbar^2)/(visc(20)*tbar))^2;
A = xbar*pbar/(rho*visc(20)*ubar);

// labels des bords du maillage

mesh Th = readmesh("mesh2.msh");

real alpha = pi / 4;     // angle incidence
real longueurTube1 = 1;  // longueur du tube d'injection
real diametreTube = 1e-1;
real rayonTube = diametreTube / 2;

int labelBordNeutre = 0;
int labelEntree1 = 1;
int labelEntree2 = 2;
int labelHautChauffe = 3;
int labelBasChauffe = 4;
int labelSortie = 5;

plot(Th, wait = 1);

// Macro
macro Grad(u)[dx(u), dy(u)]  //

// Fespace
fespace Vh(Th, P1);
Vh c, v, cc, f, b, ux, uy, beta;

// profil de Poiseuille
ux = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * cos(alpha);
uy = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * sin(-alpha) +
     longueurTube1 * sin(alpha);


real t = 0;

// Problem imp
problem dConvecDiff(c, v) = 
      int2d(Th)(c * v + dt * [ ux, uy ]'*Grad(c)*v )
    + int2d(Th)(dt * beta * mu * Grad(c)'*Grad(v) )
    - int2d(Th)(cc * v)
    - int1d(Th, 4)(dt * beta * eta * cc'*v )
  //+ on(1, 2, 3, 5, 7, 9, 11, 12, c=0)
    + on(4, c = t);

// Problem Exp
problem dConvecDiffTps(c, v) =
    int2d(Th)(1e-12 * c * v + 
        1e-9 * dt * (theta * dt * [ ux, uy ]'*Grad(c)*v +
                    theta * beta * Grad(c)'*Grad(v))) -
    int1d(Th, labelEntree1)(dt * theta * beta * [ N.x, N.y ]'*Grad(c)*v ) +
    int2d(Th)(
        (1 - theta) * dt * beta * mu * Grad(cc)'*Grad(v) +
        1e-9 * (1 - theta) * dt * [ ux, uy ]'*Grad(cc)*v  - 1e-12 * cc * v) -
    int1d(Th, labelEntree1)((1 - theta) * dt * beta * eta * [ N.x, N.y ]'*Grad(cc)*v )
    //+ on(1, 2, 3, 5, 7, 9, 11, 12, c=0)
    + on(labelEntree1, c = t);

// Time loop
cc = -x;

for (int m = 0; m <= 1 / dt; m++) {
    // Update
    t = t + dt;
    f = 0;
    cc = c;
    //beta =  x > L0 & x < L1 ? 1 : (L1 < x & x < L2 ? 1/10 : 0);
    beta = 1;
    // Solve
    dConvecDiffTps;

    // Plot
    //plot(c, fill = 1, wait = true);
}

fespace Xh(Th, P2);  // definition of the velocity component space
fespace Mh(Th, P1);  // definition of the pressure space
Xh u2, v2;
Xh u1, v1;
Xh up1, up2;
Mh p, q;

Xh ux2, uy2;

ux2 = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * cos(alpha);
uy2 = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * sin(-alpha) +
      longueurTube1 * sin(alpha);

int i = 0;
real pas = 1 / dt;
problem NS(u1, u2, p, v1, v2, q, solver = Crout,
           init = i) = 
           int2d(Th)(
            pas * (u1 * v1 + u2 * v2) +
            mu * (dx(u1) * dx(v1) + dy(u1) * dy(v1) +
                  dx(u2) * dx(v2) + dy(u2) * dy(v2)) -
            p * q * (0.000001) 
            - p * dx(v1) - p * dy(v2)
            -  dx(u1) * q - dy(u2) * q) +
           int2d(Th)(
            - pas * convect([ up1, up2 ], -dt, up1) * v1 
            - pas * convect([ up1, up2 ], -dt, up2) * v2)
           + on(labelEntree1, u1 = ux2, u2 = uy2)
           + on(labelEntree2, labelBordNeutre, labelBasChauffe,
                          labelHautChauffe, u1 = 0, u2 = 0);

// Time loop
for (i = 0; i <= 25; i++) {
  // Update
  up1 = u1;
  up2 = u2;

  // Solve
  NS;

  plot(coef = 0.2, cmm = "[u1,u2] and p", p, [ u1, u2 ], wait = 1, fill = 1);
}