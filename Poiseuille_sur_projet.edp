// param√®tres de l'EDP

real dt = 0.1;
real mu = 1;
real dP = 10;
real eta = 1;  // 1e-6;
real theta = 1;

// Params 
real vbar, xbar, ubar, pbar, rho, tbar;
real Re;
real A;

vbar = 1e-12;
xbar = 1e-6;
ubar = 1e-3;
pbar = 1e4;
rho = 1e3;
tbar = 1;

func real visc(real theta){
    real a, b, c, d, e, f;
    a = -2.53958848e-16;
    b = -2.76506905e-12;
    c = 5.95400333e-10;
    d = -4.52299564e-08;
    e = 1.72329803e-06;

    return (a * theta^4 + b * theta^3 + c * theta^2 + d * theta + e)/(1.753*1e-6);
}

Re = ((xbar^2)/(visc(20)*tbar))^2;
A = xbar*pbar/(rho*visc(20)*ubar);

// labels des bords du maillage

mesh Th = readmesh("mesh1.msh");

real alpha = pi / 4;     // angle incidence
real longueurTube1 = 1;  // longueur du tube d'injection
real diametreTube = 1e-1;
real rayonTube = diametreTube / 2;

int labelBordNeutre = 0;
int labelEntree1 = 1;
int labelEntree2 = 2;
int labelHautChauffe = 3;
int labelBasChauffe = 4;
int labelSortie = 5;

plot(Th, wait = 1);

// Macro
macro Grad(u)[dx(u), dy(u)]  //

// Fespace
fespace Vh(Th, P1);
Vh c, v, cc, f, b, ux, uy, beta;

// profil de Poiseuille
ux = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * cos(alpha);
uy = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * sin(-alpha) +
     longueurTube1 * sin(alpha);


real t = 0;

// Problem imp
problem dConvecDiff(c, v) = 
      int2d(Th)(1e-12 * c * v + dt * [ ux, uy ]'*Grad(c)*v )
    + int2d(Th)(dt * beta * mu * Grad(c)'*Grad(v) )
    - int2d(Th)(cc * v)
    - int1d(Th, 4)(dt * beta * eta * cc'*v )
  //+ on(1, 2, 3, 5, 7, 9, 11, 12, c=0)
    + on(4, c = t);

// Problem Exp
problem dConvecDiffTps(c, v) =
    int2d(Th)(1e-12 * c * v + 
        1e-9 * dt * (theta * dt * [ ux, uy ]'*Grad(c)*v +
                    theta * beta * Grad(c)'*Grad(v))) -
    int1d(Th, labelEntree1)(dt * theta * beta * [ N.x, N.y ]'*Grad(c)*v ) +
    int2d(Th)(
        (1 - theta) * dt * beta * mu * Grad(cc)'*Grad(v) +
        1e-9 * (1 - theta) * dt * [ ux, uy ]'*Grad(cc)*v  - 1e-12 * cc * v) -
    int1d(Th, labelEntree1)((1 - theta) * dt * beta * eta * [ N.x, N.y ]'*Grad(cc)*v )
    //+ on(1, 2, 3, 5, 7, 9, 11, 12, c=0)
    + on(labelEntree1, c = t);

// Time loop
cc = -x;

for (int m = 0; m <= 1 / dt; m++) {
    // Update
    t = t + dt;
    f = 0;
    cc = c;
    //beta =  x > L0 & x < L1 ? 1 : (L1 < x & x < L2 ? 1/10 : 0);
    beta = 1;
    // Solve
    dConvecDiffTps;

    // Plot
    //plot(c, fill = 1, wait = true);
}

fespace Xh(Th, P2);  // definition of the velocity component space
fespace Mh(Th, P1);  // definition of the pressure space
Xh u2, v2;
Xh u1, v1;
Xh up1, up2;
Mh p, q;

Xh ux2, uy2;

ux2 = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * cos(alpha);
uy2 = dP / (2 * mu) * (y - rayonTube) * (y + rayonTube) * sin(-alpha) +
      longueurTube1 * sin(alpha);

int i = 0;
real pas = 1 / dt;
problem NS(u1, u2, p, v1, v2, q, solver = Crout,
           init = i) = 
           int2d(Th)(
            pas * (u1 * v1 + u2 * v2) +
            mu * (dx(u1) * dx(v1) + dy(u1) * dy(v1) +
                  dx(u2) * dx(v2) + dy(u2) * dy(v2)) 
            - p * q * (0.000001) 
            - p * dx(v1) - p * dy(v2)
            -  dx(u1) * q - dy(u2) * q) +
           int2d(Th)(
            - pas * convect([ up1, up2 ], -dt, up1) * v1 
            - pas * convect([ up1, up2 ], -dt, up2) * v2)
           + on(labelEntree1, u1 = ux2, u2 = uy2)
           + on(labelEntree2, labelBordNeutre, labelBasChauffe,
                          labelHautChauffe, u1 = 0, u2 = 0);

// Time loop
for (i = 0; i <= 25; i++) {
  // Update
  up1 = u1;
  up2 = u2;

  // Solve
  NS;

  plot(coef = 0.2, cmm = "[u1,u2] and p", p, [ u1, u2 ], wait = 1, fill = 1);
}

// finite element spaces et functions
// comment the lines depdending of the choice 
// -- P2/P1 
// fespace Xh(Th,P2);
// fespace Mh(Th,P1);
// real gammap = 0.0;

// -- P1/P1 
// fespace Xh(Th,P1);
// fespace Mh(Th,P1);
// real gammap = 0.01;

// Xh ux, uy, vx, vy, uxo, uyo;
// Mh p, q, uxplot, uyplot;

// real t=0;
// // boundary data 
// func uxdata = 2.*x*(1-x)+cos(pi*t);


// // parameter to fix the pressure mean 
// real epsilon = 1e-10;

// // Stokes variational problem 
// problem Stokes([ux, uy, p], [vx, vy, q]) = 
  
//   int2d(Th)( (1./dt)*(ux*vx + uy*vy) + mu * (dx(ux)*dx(vx) + dy(ux)*dy(vx) + dx(uy)*dx(vy)+ dy(uy)*dy(vy)))
//   - int2d(Th)(p*div(vx,vy)) + int2d(Th)(div(ux,uy)*q)
  
//   // fix the pressure mean 
//   + int2d(Th)( epsilon * p*q )
  
//   // P1/P1 stabilization term. Only for P1/P1 FEM 
//   + int2d(Th)( (gammap*hTriangle^2/mu) * (dx(p)*dx(q) + dy(p)*dy(q) ))
  
//   // rhs
//   -int2d(Th)( (1./dt)*(uxo*vx + uyo*vy) )
  
//   // boundary conditions 
//   + on(1,2,4, ux=0, uy =0 )
//   + on(3, ux=uxdata, uy =0 ) ;


// real T=2.0;
// int Niter = T/dt;

// uxo = uxdata;
// uyo = 0;

// for (int n=0; n< Niter;++n) {

//   // update time step
//   t += dt ;
  
//   // solve Stokes system 
//   Stokes;

//   // update old time levels
//   uxo = ux;
//   uyo = uy;

//   // velocity plot
//   uxplot = ux;
//   uyplot = uy;
//   plot([uxplot,uyplot],wait=1);
  
//   // pressure plot 
//   plot(p,wait=1,fill=true,value=true);
  
//  }